# 1장 컴퓨터 시스템의 개요

### 컴퓨터 시스템이 동작할 때 하드웨어가 동작하는 순서

1. 입력장치 혹은 네트워크 어댑터를 통해서
2. 컴퓨터에 무언가 처리요청이 들어옵니다.
3. 메모리에 있는 명령을 읽어 CPU에서 실행하고
4. 그 결과값을 다시 메모리의 다른 영역에 기록합니다.
5. 그리고
    1. 메모리의 데이터를 하드디스크나 SSD 등의 저장 장치에 기록 또는
    2. 네트워크를 통해 다른 컴퓨터에 전송하거나
    3. 디스플레이 등의 출력장치를 통해 사람에게 결과값을 보여줍니다.
6. 1번부터 반복해서 실행합니다.

### 프로그램의 종류

- 애플리케이션
- 미들웨어
- OS : 여러가지 프로그램을 프로세스라고 하는 단위로 실행한다.

### 리눅스

- 리눅스의 중요한 역할은 외부 장치 (이하 디바이스)를 조작하는 일
- 리눅스에서는 디바이스 드라이버를 통해서만 프로세스가 디바이스를 조작할 수 있다.
- 리눅스는 디바이스의 종류가 같으면 같은 인터페이스로 조작하도록 되어있다.
- 리눅스는 CPU 에 있는 기능을 이용하여 프로세스가 직접 하드웨어에 접근하는 것을 차단합니다.

### 리눅스의 모드

- 커널모드
    - 디바이스 접근가능
    - 디바이스 드라이버는 커널 모드로 동작
    - 프로세스 관리 시스템
    - 프로세스 스케줄링
    - 메모리 관리 시스템
- 사용자모드
    - 프로세스 실행
    - 프로그램 작성
    - 시스템 콜
    - ***프로세스가 디바이스 드라이버를 포함한 커널이 제공하는 기능을 사용하려 할 때는 시스템 콜이라고 하는 특수한 처리를 통해 요청합니다.

### 커널이란?

- 커널 모드에서 동작하는 OS의 핵심부분이 되는 처리를 모아 담당하는 프로그램
- 커널은 시스템에 탑재된 CPU 나 메모리등의 리소스를 관리하고 있으며 리소스의 일부를 시스템에 존재하는 각 프로세스에 적절히 분배.

### OS는

- 커널만을 지칭하지 않습니다.
- 커널 이외 에도 사용자 모드에서 동작하는 다양항 프로그램으로 구성되어 있습니다.

---

# 2장 사용자모드로 구현되는 기능

### 시스템콜

- 프로세스는 프로세스의 생성이나 하드웨어의 조작 등 커널의 도움이 필요한 경우 시스템 콜을 통해 커널에 처리를 요청합니다.
- 다음은 시스템 콜의 종류입니다.
    - 프로세스 생성, 삭제
    - 메모리 확보, 해제
    - 프로세스 간 통신(IPC)
    - 네트워크
    - 파일시스템 다루기
    - 파일 다루기 (디바이스 접근)

### CPU의 모드 변경

- 시스템 콜은 CPU의 특수한 명령을 실행해야만 호출됩니다.
- 프로세스는 보통 사용자 모드로 실행되고 있지만 커널에 처리를 요청하고자 시스템 콜을 호출하면 CPU 에서는 인터럽트 이벤트가 발생된다.
- 인터럽트 이벤트가 발생시 CPU는 사용자 모드에서 커널 모드로 변경되어 요청한 내용을 처리하기 위해 커널은 동작하기 시작합니다.
- 요청한 내용의 처리가 끝나면 시스템 콜 처리가 종료되어 다시 사용자 모드로 돌아가 프로세스의 동작을 계속 진행합니다.

### 리눅스의 지표 분석 커맨드 : sar & sysstat

```
$ sar -p ALL 1  #---- 실행해보면
[root@vincekim ~]# sar

Linux 2.6.32.59-0.7-xen (jmnote)  10/24/12  _x86_64_
00:00:01        CPU     %user     %nice   %system   %iowait    %steal     %idle
00:10:01        all     20.63      0.00     11.65      2.17      0.08     65.46
00:20:01        all      9.32      0.00      4.34      1.99      0.05     84.30
00:30:01        all     11.32      0.00      6.61      1.17      0.13     80.77
... (생략)
Average:        all     10.28      0.00      6.03      2.03      0.12     81.53
```

### 결과값 설명

- %user 와 %nice
    - 사용자모드에서 프로세스를 사용하고 있는 시간의 비율
- %system
    - CPU 코어가 커널 모드에서 시스템 콜 등의 처리를 실행하고 있는 시간의 비율
- %idle
    - CPU 상의 프로세스도 커널도 움직이지 않고 있는 아이들의 상태를 의미
- 시스템 콜의 OS Wrapper 함수
    - 리눅스에 는 프로그램의 작성을 도와주기 위해 프로세스 대부분에 필요한 여러 라이브러리 함수가 있습니다.
    - 시스템 콜은 보통의 함수 호출과는 다르게 C언어 등의 고급언어에서는 직접 호출이 불가능 합니다. 아키텍처에 의존하는 어셈블리 코드를 사용해 호출할 필요가 있습니다.

---

# 3장 프로세스 관리

### 프로세스 생성의 목적

- 리눅스에서는 여러가지 목적으로 프로세스를 생성합니다.
- 목적 1 :
    - 같은 프로그램의 처리를 여러 개의 프로세스가 나눠서 처리.
    - 예를들어 웹서버 처럼 요청이 여러 개 들어왔을 때 동시에 처리해야 하는 경우
- 목적 2 :
    - 전혀 다른 프로그램을 생성합니다.
    - 예를들어 bash 로부터 각종 프로그램을 새로 생성하는 경우
- 그리고 해당 목적에
    - fork와 execve() 함수를 사용합니다.
    - 시스템 내부에서는 clone 과 execve 시스템 콜을 호출합니다.

### fork() 함수

- 같은 프로그램의 처리를 여러개의 프로세스가 나눠서 처리합니다.
- 위 목적 1에는 fork() 함수만을 사용합니다.
- fork 함수에서는 새로운 프로세스가 생성됩니다.
    - 생성전의 프로세스를 부모 프로세스
    - 새롭게 생성된 프로세스를 자식 프로세스라고 부릅니다.
- 순서
    1. 자식 프로세스용 메모리 영역을 작성하고 거기에 부모 프로세스의 메모리를 복사.
    2. fork() 함수의 리턴 값이 각기 다른 것을 이용하여 부모 프로세스와 자식 프로세스가 서로 다른 코드를 실행하도록 분기.

### execve() 함수

- 전혀 다른 프로그램을 생성할 때에는 execve 함수를 사용합니다.
- 커널이 각각의 프로세스를 실행하기까지의 흐름을 살펴보면
    1. 실행 파일을 읽은 다음 프로세스의 메모리 맵에 필요한 정보를 읽어 들입니다.
    2. 현재 프로세스의 메모리를 새로운 프로세스의 데이터로 덮어씁니다.
    3. 새로운 프로세스의 첫 번째 명령부터 실행합니다.

### ELF ( Excectuable and Linkable Format )

- 리눅스의 실행 파일은 실제로는 위에서 설명한 것 같은 단순한 것이 아니라 ELF 라는 형식을 사용합니다.
- ELF 형식의 각종 정보는 readelf 명령어로 자세히 살펴 볼 수 있습니다.

```
#-----    /bin/sleep의 정보를 예로 살펴보겠습니다.
#-----    "-h" 옵션을 지정하면 시작 주소를 얻을 수 있습니다.

readelf -h /bin/sleep
```

- 코드와 데이터 영역의 파일상의 오프셋, 사이즈, 메모리 맵 시작 주소를 얻으려면 -S 옵션을 사용합니다.
- 출력된 내용은 두 줄이 하나의 정보세트입니다.
- 수치는 전부 16진수 입니다.
- 세트 중 첫 줄의 두번째 필드가 .text 이면 코드 영역 .data 이면 데이터 영역의 정보를 의미합니다.
- 세트의 다음 위치를 보면 알 수 있는 정보들입니다.
    - 코드 영역의 파일상 오프셋
    - 코드 영역의 사이즈
    - 코드 영역의 메모리 맵 시작 주소
    - 데이터 영역의 사이즈
    - 데이터 영역의 메모리 맵 시작 주소
    - 엔트리 포인트

### fork and exec

- fork and exec 전혀 다른 프로세스를 새로 생성할 때 사용하는 방식
    - 부모가 될 프로세스로부터 fork() 함수를 호출한 다음
    - 돌아온 자식 프로세스가 exec() 함수를 호출
- 프로그램 종료
    - _exit() 함수를 사용
    - / 내부에서는 exit_group() 시스템 콜을 호출합니다.

---

# 4장 프로세스 스케줄러

### 프로세스 스케줄러

- 리눅스 커널의 기능
- 여러 개의 프로세스를 동시에 동작 시킨다. (정확히는 동작시키는 것처럼 보이게 한다.)
- 설명
    - 하나의 CPU 는 동시에 하나의 프로세스만 처리할 수 있습니다.
    - **타임 슬라이스 : 하나의 CPU 에 여러 개의 프로세스를 실행해야 할 때 각 프로세스를 적절한 시간으로 쪼개서 번갈아 처리하는 것
- 예
    - 하나의 CPU에 p0, p1, p2, p 3개의 프로세스가 있다면
    - 그러면 CPU는 여러 프로세스를 횡단하며 한 순간에 하나의 프로세스 씩 동작시킵니다.

### 논리 CPU

- 리눅스에서 멀티코어 CPU 는 1개의 코어가 1개의 CPU 로 인식됩니다.
- 이번 책에서는 논리 CPU 라고 합니다.
- 더불어 하이퍼스레드 기능이 있으면 각 코어 내의 각각의 하이퍼스레드가 논리 CPU 로 인식됩니다.

### 예시

- 실험 : 프로세스를 1, 2, 4개로 나눠서 하나의 논리 CPU 에서 동작시킨다.
- 설명 :
    - 동시에 프로세스를 여러 개 실행하더라도 특정 순간에 논리 CPU 에서 동작되는 프로세스는 1개뿐
    - 논리 CPU 에는 여러 개의 프로세스가 순차적으로 1개씩 동작합니다.
    - *** 첫 번째 프로세스부터 마지막 프로세스까지 프로세스가 한 바퀴 다 돌고 나면 다시 첫 번째 프로세스 부터 동작하는 라운드로빈 방식으로 동작하고 있습니다.
    - 각 프로세스는 대략 같은 타임 슬라이스를 가집니다.
    - 프로세스를 종료할 때까지의 경과 시간은 프로세스 수에 비례하여 증가합니다.

### 컨텍스트 스위치

- 논리 CPU 상에서 동작하는 프로세스가 바뀌는 것을 "컨텍스트 스위치"라고 부릅니다.
- 컨텍스트 스위치에서는 프로세스가 어떤 프로그램을 수행 중이더라도 타임 슬라이스를 모두 소비하면 발생합니다.
- 특정 프로그램을 처리중에 중간에 컨텍스트 스위치가 발생해서 다른 프로세스가 움직였을 가능성도 있어 라는 다른 관점을 가져야합니다.

### 프로세스의 상태

- ps ax 명령어로 시스템에 존재하는 프로세스를 한 줄씩 목록으로 확인할 수 있습니다.
- 각각의 환경마다 결과값은 다르게 출력되며 실행할 때마다 미묘하게 수치가 바뀜.
- ' | wc -l  ' 파이프로 갯수를 새어볼 수 있습니다.

```
$ ps ax | wc -l
364
```

### 프로세스의 상태들

- 상태 종류
    - 실행 상태 : 현재 논리 CPU 를 사용하고 있다.
    - 실행 대기 상태 : CPU시간이 할당 되기를 기다리고 있습니다.
    - 슬립상태 : 이벤트가 발생 하기를 기다리고 있으며 이벤트 발생 까지는 CPU 시간을 사용하지 않습니다.
        - 이벤트의 예
            - 정해진 시간이 경과하는 것을 기다린다. (예, 3분 대기)
            - 키보드나 마우스 같은 사용자 입력을 기다립니다.
            - HDD나 SSD 같은 저장 장치의 읽고 쓰기의 종료를 기다립니다.
            - 네트워크의 데이터 송수신의 종료를 기다립니다.
    - 좀비상태 : 프로세스가 종료한 뒤 부모 프로세스가 종료 상태를 인식할 때까지 기다리고 있습니다.

### 프로세스의 상태 확인하기

- 각 프로세스의 상태는 ps ax 를 실행했을 때 출력되는 결과의
- 세 번째 필드인 'STAT' 필드의 첫 문자를 보면 알 수 있습니다.

```
$ ps ax
  PID   TT  STAT      TIME COMMAND
    1   ??  Ss     0:50.20 /sbin/launchd
   69   ??  Ss     0:01.29 /usr/sbin/syslogd
   70   ??  Ss     0:01.35 /usr/libexec/UserEv
```

- STAT 필드 타입
    - R : 실행 상태 혹은 실행 대기 상태
    - S 혹은 D
        - 슬립 상태,
        - S 시그널에 따라 실행상태로 되돌아오는 것이 D
        - D 그렇지 않은것 / 후자는 주로 저장장치의 접근 대기
            - D 상태에 있는 프로세스는 일반적으로 수 밀리초정도 지나면 다른 상태로 바뀝니다.
            - 장시간을 D 상태로 있다면 다음과 같은 원인을 생각해볼 수 있습니다.
            - 스토리지의 I/O가 종료되지 않은 상태로 되어있습니다.
            - 커널 내에 뭔가 문제가 발생하고 있습니다.
    - Z : 좀비 상태

### 프로세스의 상태변환의 순서

- 프로세스 생성
- 대기 / 실행 / 슬립 상태를 오고간 후
- 좀비상태
- 프로세스 종료

### idle 상태

- 어떤 논리 CPU에서 동작하지 않은 시간이 있다면
    - 이때 논리 CPU에서는 idle 프로세스라고 하는 아무것도 하지 않는 특수한 프로세스가 동작하고 있습니다.

### idle 프로세스의 가장 단순한 구현

- CPU의 특수한 명령어를 이용하여 논리 CPU를 휴식 상태로 만들어 하나 이상의 프로세스가 실행가능한 상태가 될 때까지 아무 의미 없는 루프를 하는 것
- 위 처럼 만들면 전력만 낭비하기 때문에 이렇게 구현하지는 않습니다.
- 그 대신 CPU의 특수한 명령을 이용하여 논리 CPU를 휴식 상태로 만들어 하나 이상의 프로세스가 실행 가능한 상태가 될 때까지 소비 전력을 낮춰 대기상태로 만듭니다.
- 논리 CPU가 소비 전력이 낮은 idle 상태로 오래 있기 때문입니다.
    - 노트북이나 스마트폰으로 아무것도 하지 않는 상태일 때 배터리가 오래가는 이유

### sar 커맨드

- 커맨드를 사용하면 단위 시간당 논리 CPU가 얼마나 idle 상태가 되는지, 어느 정도 계산 리소스에 여유가 있는지를 확인할 수 있습니다.
- 이전예제 참고

```
sar -P ALL 1
```

### 중요 포인트

1. 논리 CPU 로 한 번에 실행할 수 있는 프로세스는 1개뿐 입니다.
2. 슬립 상태에서는 CPU 시간을 사용하지 않습니다.

### 성능지표 : Throughput & Latency

- 스루풋 :
    - 단위 시간당 처리된 일의 양
    - 높을수록 좋다
    - 완료한 프로세스의 수 / 경과시간
    - idle 상태의 시간이 적어지면 적어질 수록 쓰루풋이 높아진다.
    - 프로세스를 여러개 사용하면 프로세스의 슬립상태 (논리 CPU의 idle 상태)가 줄어들며 스루풋이 높아진다.

- 레이턴시 :
    - 각각의 처리가 시작부터 종료까지의 경과된 시간으로 짧을수록 좋습니다.
    - 처리 종료 시간- 처리 시작 시간
- 요점 :
    - 이러한 성능지표는 논리 CPU 뿐만 아니라 저장 장치 등의 다른 성능에서도 중요합니다.
    - 논리 CPU의 능력을 전부 활용, 즉 모든 CPU가 idle 상태가 되지 않는 경우에는 프로세스 갯수를 늘려도 스루풋은 변하지 않습니다.
    - 프로세스를 늘릴 수록 레이턴시는 악화된다.
    - 각 프로세스의 평균 레이턴시는 비슷합니다.

### 실제시스템도 같나요?

- 이상적인 상황에서는 CPU가 항상 움직이는, 즉 idle 상태가 없는 경우와 실행 대기 상태의 프로세스가 없는 경우에 스루풋과 레이턴시 모두 최대가 됨을 알 수 있습니다.
- 하지만 현실에서는 실제 시스템에 돌아가는 논리 CPU는 아래과 같은 상태를 정신없이 오고 갑니다.
    - idle :
        - 논리 CPU가 쉬고 있기때문에 스루풋이 떨어진다.
    - 프로세스가 동작중 :
        - 실행 대기의 프로세스가 없기 때문에 이상적인 상태입니다.
        - 이러한 상태는 다음의 프로세스가 실행 가능한 상태가 되면, 2개의 프로세스의 레이턴시가 양쪽 다 길어집니다.
    - 프로세스가 대기 중 :
        - 실행 대기 프로세스가 있습니다.
        - 스루풋은 높지만 레이턴시가 길어지는 경향이 있습니다.
- 그러므로 스루풋과 레이턴시는 서로 trade-off 관계 에 있는 경우가 많습니다.
- 실제로 시스템을 설계할 때에는 성능 목표로 필요한 스루풋과 레이턴시를 정의한 뒤에, 특정 목표치 설정 후 이를 달성할 수 있는 시스템을 튜닝해야합니다.

### 논리 CPU가 여러 개일 때 스케줄링

- 로드밸런서 혹은 글로벌 스케줄 : 여러 개의 논리 CPU에 프로세스를 공평하게 분배해주는 역할을 한다.

### 실험 : 1개, 2개, 그리고 4개의 프로세스를 하나의 CPU에서 실행 시

- 정리
    - 1개의 CPU에 동시에 처리되는 프로세스는 1개입니다.
    - 여러 개의 프로세스가 실행 가능한 경우 각각의 프로세스를 적절한 길이의 시간(타임슬라이스) 마다 CPU에서 순차적으로 처리합니다.
    - 멀티코어 CPU 환경에서는 여러 개의 프로세스를 동시에 동작시키지 않으면 스르풋이 오르지 않습니다.
    - '코어가 n 개 있으므로 성능이 n배' 라고 말할 수 있는건 어디까지나 최선의 케이스인 경우입니다.

### 경과 시간과 사용 시간

- time 명령어를 통해서 프로세스를 동작시키면 프로세스의 시간부터 종료까지의 시간 사이에 경과시간과 사용시간이라는 두 가지 수치를 얻을 수 있습니다.
- 경과시간 :
    - 프로세스가 시작해서 종료할 때 까지의 시간
- 사용시간 :
    - 프로세스가 실제로 논리 CPU 를 사용한 시간

```
# 프로세스 하나를 실행시키기는 예재

$ time taskset -c 0 ./sched 1 1000 10000
```

- time 의 아웃풋
    - 경과시간 : 'real' 의 값
    - 사용시간 : 그 아래 'user' 와 'sys' 의 수치의 합
        - 'user' 의 값은 프로세스가 실행 중인 사용자 모드에서 CPU를 사용한 시간.
        - 'sys'의 값은 프로세스의 실행중에 사용자 모드의 처리로부터 호출된 커널이 시스템 콜을 실행한 시간

### 경과 시간과 사용 시간

- 경과시간은 동일한데 사용시간이 두배가 될 수 있는 케이스
    - CPU1개에서 2개의 프로세스를 작업한것과
    - CPU2개에서 4개의 프로세스를 작업
- 경과시간 모든 CPU 에 1개의 CPU 당 2개의 프로세스가 할당되기 때문에 동일하다
- 사용시간은 2배
    - CPU가 사용된 시간은
    - 1개가 10초걸린다면
    - 2개면 10초 +10초
- 슬립을 10초 사용하면?
    - 경과시간은 10초 더 늘어나지만
    - 사용시간은 변하지 않는다.

### time 외에 다른 방법으로 프로세스의 경과 시간과 사용 시간을 얻는 방법

```
## 프로세스아이디, 명령어이름, 경과시간, 사용시간

ps -eo pid,comm,etime,time
```

- 논리 CPU 1개에서 같은 프로세스 2개를 실행하기

```
$ taskset -c 0 python3 ./loop.py &
[1] 21304
$ taskset -c 0 python3 ./loop.py &
[2]  21306
$ ps -eo pid,comm,etime,time | grep python3
21304 python3 00:19 00:10 #------- 사용시간이 경과 시간의 약 절반
21306 python3 00:19 00:10 #------- 사용시간이 경과 시간의 약 절반
$ kill 21304 21306
```

- 프로세스당 사용시간이 경과 시간의 약 절반이 된다.
- 논리 CPU 0을 프로세스 두 개가 나누고 있기 때문에

### nice() : 프로세스의 우선순위 변경

- nice() 시스템 콜
- 특정 프로세스에 우선 순위를 부여하는 것
- 기본값은 0
- 범위는 -19 ~ 20까지
- -19가 가장 우선순위가 높고 20이 가장 낮음.
    - 우선순위가 높은 프로세스는 평균보다 더 많은 CPU시간을 배정 받고
    - 반대로 낮은 프로세스는 적게 받는다.
- 우선 순위 변경 권한
    - 우선 순위를 내리는 것은 모든 사용자가 가능하지만
    - 낮추는것은 root 유저만 가능

> sar 출력시 나오는 %nice 필드는 우선순위를 디폴트 값인 0부터 변경한 프로그램을 실행한 시간의 할당량을 나타냅니다.
<br />
