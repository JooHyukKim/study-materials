# Day 2 ( Chapter 9 )

## 9. 면접 문제

- 자료구조
    1. 배열과 문자열
    2. 연결 리스트
    3. 스택과 큐
    4. 트리와 그래프
- 개념과 알고리즘
    5. 비트 조작
    6. 수학 및 논리 퍼즐
    7. 객체 지향 설계
    8. 재귀와 동적 프로그래밍
    9. 시스템 설계 및 규모 확장성
    10. 정렬과 탐색
    11. 테스팅
- 지식 기반 문제
    12. C와 C++
    13. 자바
    14. 데이터베이스
    15. 스레드와 락
- 추가 연습 문제
    16. 중간 난이도 연습 문제
    17. 어려운 연습문제
     
----

# 자료구조

---

## 1. 배열과 문자열

- 배열과 문자열에 널리 사용되는 한결 보편적인 기법들에 집중할 것이다.
- 배열이나 문자열에 대한 문제들은 서로 대체 가능하다. 즉, 배열에 관한 무제들은 문자열에 대한 문제로 서로 바꿔 출제도 가능하다.

### 1.1. 해시테이블

해시 테이블은 효율적인 탐색을 위한 자료구조로서 키를 값에 대응시킨다.

해시 테이블을 구현하는 방법은 여러가지가 있다.

방법 1.

    간단한 해시테이블을 구현하기 위해선, 연결리스트와 해시 코드 함수만 있으면 된다.
    키와 값을 해시테이블에 넣을 때는 다음의 과정을 거친다.

    1. 처음엔 해시코드를 계산한다. 보통 int 또는 long 이 된다.
    2. 그 다음엔 hash(key) % array_length 와 같은 방식으로 해시 코드를 이용해 배열의 인덱스를 구한다.
    3. 배열의 각 인덱스에는 키와 값으로 이루어진 연결리스트가 존재한다. 키와 값을 해당 인덱스에 저장한다.
    4. 키의 값을 구하기 위해선 입력값을 2번 연산을 통해 연결리스트에서 탐색한다.

방법 2.

    다른 방법으로는 균형 이진 탐색 트리를 사용하는 방법이 있다.
    이 방법은 배열을 미리 할당해 놓지 않아도 되기 때문에 잠재적으로 적은 공간을 사용한다는 장점이 있다.

### 1.2. ArrayList 와 가변 크기 배열

    특정 언어에선 배열의 크기를 자동으로 조절 할 수 있다. 

    즉 데이터를 덧붙일 때마다 배열 혹은 리스트의 크기가 증가한다. 

    자바에서는 ArrayList를 사용하는데 배열이 가득차는 순간 배열의 크기를 두배로 늘린다.

### 1.3. StringBuilder

     StringBuilder 는 문자열 연산의 무게감을 덜어준다. 단순하게 가변 크기 배열을 이용해서 필요한 경우에만 문자열을 복사하게끔 해준다.

---

## 2. 연결리스트

    연결리스트는 차례로 연결된 노드를 표현해주는 자료구조다. 단방향 연결리스트에서 각 노드는 다음 노드를 가리킨다.
    양방향 연결리스트에서 각 노드는 다음 노드와 이전 노드를 함께 가리킨다.

    배열과는 달리 연결리스트에서는 특정 인덱스를 상수시간에 접근할 수 없다.
    그 말인즉슨 리스트에서 K번째 원소를 찾고 싶다면 처음부터 K번 루프를 돌아야 한다.

    연결리스트의 장점은 리스트의 시작 지점에서 아이템을 추가하거나 삭제하는 연산을 상수시간에 할 수 있다는 점이다.
    이런 점은 특정 애플리케이션에서 유용하다.

### 2.1. 연결리스트 만들기

    여러 객체들이 동시에 연결리스트를 참조하는 도중에 head가 바뀌면 어떻게 해야 할지 생각해 봐야 하는 것이다. 

    할 수 있다면 Node 클래스를 포함하는 LinkedList 클래스를 만드는게 좋다. 

    그렇게 하면 해당 클래스 안에 head Node 변수를 단 하나만 정의해 놓음으로써 위의 문제점을 완전히 해결할 수 잇기 때문이다. 

    면접에서 연결리스트에 대해 이야기 할 때는 단방향 /양방향 연결리스트 인지 반드시 인지하고 있어야 한다.

### 2.2. 단방향 연결리스트에서 노드 삭제

    방법은 매우 직관적이다.

    노드 n이 주어지면, 그 이전 노드를 찾아 prev.next를 n.next와 같도록 설정한다.
    리스트가 양방향인 경우에는 n.next 가 가리키는 노드를 갱신하여 n.next.prev가 n.prev와 같도록 설정해야 한다.

    주의할 점
        첫 번째, null 포인터 검사를 반드시 해야 한다
        두 번째, 필요하면 head와 tail 포인터도 갱신해야 한다.

### 2.3. Runner (부가 포인터)

    - 연결리스트 문제에서 많이 활용되는 기법이다. 연결리스트를 순회할 때 두 개의 포인터를 동시에 사용하는 것이다.
    - 이때 한 포인터가 다른 포인터보다 앞서도록 한다.
    - 앞서 포인터가 따라오는 포인터보다 항상 지정된 개수만큼을 앞서도록 할 수도 있고, 아니면 따라오는 포인터를 여러 노드를 한번에 뛰어넘도록 설정할 수도 있다.

### 2.4. 재귀 문제

    - 연결리스트 관련 문제 가운데 상당수는 재귀호출에 의존한다.
    - 연결리스트 문제를 푸는 데 어려움을 겪고 있다면 재귀적 접근법은 통할지 확인해 봐야 한다. (이후 챕터 참고)

--------

## 3. 스택과 큐

### 3.1. 스택 구현하기

    스택은 말그대로 쌓아 올린다. 문제에 따라 배열보다 스택이 더 적합할 수도 있다. 
    LIFO(Last in First out)
    스택이 유용한 경우는 재귀 알고리즘을 사용할 때다. 
    재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어 주고, 재귀 함수를 빠져나와 퇴각 검색을 할 때는 스택에 넣어 두었던 임시 데이터를 빼 줘야 한다.

### 3.2. 큐 구현하기

    FIFO (First in First Out)
    큐 또한 연결리스트로 구현할 수 있다.

    큐는 BFS를 구현하거나 캐시를 구현하는 경우에 종종 사용된다.

-------

## 4. 트리와 그래프

    면접에 임하는 많은 지원자들이 가장 까다로워 하는 문제 중 하나가 트리나 그래프 문제인 것 같다.

    트리에서 탐색하는 것이 배열이나 연결리스트처럼 선형으로 구성된 자료구조에서 탐색하는 것보다 훨씬 까다롭다.

    또한, 최악 수행 시간과 평균적 수행 시간이 매우 크게 바뀔 수 있어서, 알고리즘을 살펴볼 때에는 두가지 측면 모두를 반드시 따져봐야 한다. 

### 4.1. 트리의 종류

    트리는 하나의 루트 노드를 갖는다.(필수는 아니지만)
    루트 노드는 0 개 이상의 자식 노드를 갖고있다.
    그 자식 노드 또한 0개 이상의 자식 노드를 갖고 있고, 이는 반복적으로 정의 된다.

    @ 트리 vs 이진 트리

        이진 트리는 각 노드가 최대 두 개의 자식을 갖는 트리.
        모든 트리가 이진 트리는 아니다. 삼진 트리라고도 부른다. 
        자식이 없는 노드는 '말단' 노드라고 부른다.

    @ 이진 트리 이진 탐색 트리
        이진 탐색 트리는 모든 노드가 다음과 같은 속성을 갖는 이진 트리를 말한다.
        '모든 왼쪽 자식들 <= n < 모든 오른쪽 자식들' 속성은 모든 노드 n에 대해서 반드시 참이어야 한다.


    @ 균형 vs 비균형
        균형 잡는 것은 상황별 다르게 표현될 수도 있으니 이 부분은 면접관과 협의를 해야한다.

    @ 완전 이진 트리
        모든 높이에서 노드가 꽉 차 있는 이진 트리.
        마지막 레벨은 꽉차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다.

    @ 전 이진 트리
        모든 노드가 자식이 없거나 정확히 두개 있는 경우를 말한다.

    @ 포화 이진 트리
        전 이진 트리이면서 완전 이진트리인 경우를 말한다.

### 4.2. 이진 트리 순회

    중위 순회
        > 왼쪽 > 루트 > 오른쪽

    전위 순회
        > 루트 > 왼쪽 > 오른쪽

    후위 순회
        > 왼쪽 > 오른쪽 > 루트

### 4.3. 이진 힙 (최소힙과 최대힙)

     ! 최소힙과 최대힙은 정렬 차이만 있고 완전히 같다.
     ! 최소힙은 트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져 있다는 점에서 완전 이진트리이며, 각 노드의 원소가 자식들의 원소보다 작다는 특성이 있다.
     ! 따라서 루트는 트리 전체에서 가장 작은 원소가 된다.

    삽입
        완전 트리의 속성에 위배되지 않게 새로운 원소는 밑바닥 가장 오른쪽 위치로 삽입된다.
        그 다음에 새로 삽입된 원소가 제대로 된 자리를 찾을 때까지 부모 노드와 교환해 나간다.
        기본적으로 이와 같은 방식으로 최소 원소를 위쪽으로 올린다.

    최소 원소 뽑아내기
        
        최소 원소 찾기란 쉽고, 제거 하는 부분만 아주 조금까다롭다.
        제거하기
            1. 제거한 후에 힙에 있는 가장 마지막 원소와 교환한다.
            2. 최소힙의 성질을 만족하도록, 해당 노드를 자식 노드와 교환해 나감으로써 밑으로 내보낸다.

### 4.4. 트라이 (접두사 트리)

    n 차 트리의 변종으로 각 노드에 문자를 저장하는 자료구조이다. 
    다라서 트리를 아래쪽으로 순회하면 단어 하나가 나온다.
    null 노드라고 불리우는 '* 노드' 는 종종 단어의 끝을 나타낸다.
    단어의 끝은 노드의 boolean 플래그로도 표현이 가능하다.

### 4.5. 그래프

> 트리는 그래프의 한 종류이다. 그렇다고 모든 그래프가 트리는 아니다. 트리는 사이클이 없는 하나의 연결 그래프이다. 그래프는 단순히 노드와 그 노드를 연결하는 간선을 하나로 모아놓은 것이다.

    - 그래프에는 방향성이 있을 수도, 없을 수도 있다.
    - 방향성이 있는 간선은 일방통행, 없는 간선은 양방향 통행 도로라고 생각하면 된다.
    - 그래프는 여러개의 고립된 부분 그래프로 구성될 수 있다
        - 모든 정점 쌍 간에 경로가 존재하는 그래프는 "연결 그래프"라고 부른다.
    - 그래프에는 사이클이 존재할 수도 있고 존재하지 않을 수도 있다.
        - 사이클이 존재하지 않는 그래프는 "비순환 그래프"라고 부른다.

인접리스트

    - 그래프를 표현할 때 사용되는 가장 일반적인 방법이다.
    - 모든 정점(혹은 노드)을 인접 리스트에 저장한다. 
    - 무방향 그래프에서 간선은 (a,b) 두번 저장된다. 
        - 한번은 a정점에 인접한 간선을 저장하고 다른 한 번은 b에 인접한 간선을 저장한다.
    - 한 번은 a 정점에 인접한 간선을 저장하고 다른 한 번은 b에 인접한 간선을 저장한다.

인접 행렬

    - N x N 불린 행렬
    - 인접 리스트를 사용한 그래프 알고리즘들, 예를 들어 너비 우선 탐색 또한 인접 행렬에서도 사용 가능하다.
    - 하지만 인접 행렬은 조금 효율성이 떨어진다. 어떤 노드를 찾기 위해서는 모든 노드를 전부 순회해야 알수도 있기 때문이다.

그래프 탐색

    일반적으로 깊이 우선 탐색 (DFS) 너비 우선 탐색 (BFS)가 있따. 

    ! DFS 깊이 우선 탐색
        - 모든 노드를 방문하고자 할 때 더 선호되는 편이다. 그리고 좀 더 간단하다.
        - 재귀적으로 표현이 가능하다.

    ! BFS 너비 우선 탐색  
        - 두 노드 사이의 최단 경로, 혹은 임의의 경로를 찾고 싶을때 더 낫다.
        - 예를 들어 인간관계..? 가장 가까운 친구들을 통해서 알아보기
        - BFS는 재귀적으로 동작하지 ***않는다***.
        - BFS는 큐를 사용한다.

    ! 양방향 탐색
        - 출발지와 도착지 사이에 최단 경로를 찾을때 사용된다.
        - 기본적으로 출발지와 도착지 두 노드에서 동시에 너비 우선 탐색을 수행한 뒤,두 탐색 지점이 충돌하는 경우에 경로를 찾는 방식이다.
        - 양방향 탐색 방식이 더 빠른이유
            - 전통적인 너비 우선 탐색을 사용한다면 첫 단계에서 K개의 노드를 탐색해야 할것이다.
                - 다음 단계에선 k 개의 노드들 또한 이웃한 k 개의 노드를 탐색해야 하므로 총 k^2 개의 노드를 탐색해야한다.
            - 양방향 탐색을 사용한다면 두 탐색 알고리즘이 대략 d/2단계까지 탐색한 후에 충돌할 것이다.
                - 다라서 s와 t 각각에서 방문하게 될 노드의 수는 대략 k^(d/2) 개가 될 것이고 따라서 방문하게 될 전체 노드는 대략 2*k^(d/2), O(k^(d/2))개가 된다.

-------

## 5. 비트 조작 ! 다음 내용은 개별적으로 공부할 필요가 있으므로 책에서 직접 확인하면 좋겠다.

    - 손으로 비트 조작해보기
    - 비트 조작을 할 때 알아야 할 사실들과 트릭들
    - 2의 보수와 음수
    - 산술 우측 시프트 vs 논리 우측 시프트
    - 기본적인 비트 조작 : 비트값 확인 밑 채워 넣기

-----

## 6. 수학 및 논리 퍼즐

    - 소수 판별
      - 가분성
      - 소수 판별
      - 소수 목록 만들기 : 에라토스테네스의 체
    - 확률
      - A&B의 확률
      - A|B의 확률
      - 독립성
      - 상호 배타
    - 입을 열라 : 수수께끼 같은 문제를 만나게 되면 당황하지말라. 알고리즘 문제와 마찬가지로, 면접관들이 원하는 것은 여러분이 문제르 ㄹ어떻게 공략해 나가는지 보는 것이다.
    - 규칙과 패턴을 찾으라 
    - 최악의 경우는?
    - 알고리즘적 접근 : 문제를 풀다가 막혔다면, 알고리즘 문제를 푸는 접근법 가운데 하나를 적용해보자. 수수꼐끼처럼 보이는 문제들 중 상당수는 기술적인 측면을 제거한 알고리즘 문제인 경우가 많다. 초기 사례로부터의 확장법 그리고 스스로 풀어보기가 특히 유용하게 쓰일 수 있다.

----

## 7. 객체 지향 설계

### 7.1. 접근법

    객체가 나타내는 것이 물리적 개체이건 기술적 작업이건 간에, 객체 지향 설계에 관한 질문들은 거의 비슷한 방식으로 공략 가능하다.
    많은 문제들에 대해서 아래와 같은 접근법을 사용하면 효과적이다.

    단계 1 : 모호성의 해소

    - 객체 지향 설계에 관한 질문을 받으면, 누가 그것을 사용할 것이며 어떻게 사용할 것인지에 대한 질문을 던져야 한다.
    - 질문에 따라서는 육하원칙에 따른 질문을 던져야 할 때도 있다.
      - 누가, 무엇을, 어디서, 언제, 어떻게, 왜

    단계 2 : 핵심 객채의 설계

    - 무엇을 설계할 것인지 이해했으니, 시스템에 넣을 '핵심 객체'가 무엇인지 생각해 봐야 한다. 예를들어 식당을 객체지향적으로 설계한다고 해보면 핵심 객체로는 Table, Guest, Party, Order, Meal Employee, Server, Host 등이 있을 수 있다.

    단계 3 : 관계 분석

    - 핵심 객체를 어느 정도 결정했다면, 이제 객체 사이의 관계를 분석해야 한다.
      - 멤버 (객체가 다른 객체에 속해있다)
      - 상속
      - 관계 (One-to-Many, Many-to-Many)

    단계 4 : 행동 분석

    - 여기서 부터는 객체가 수행해야 하는 핵심 행동들에 대해서 생각하고, 이들이 어떻게 상호작용해야 하는지 따져 보는 것이다. 이 과정에서 설계를 변경해야 할 수도 있다.

### 7.2. 디자인 패턴

    - 싱글톤 클래스 : 어떤 클래스가 오직 하나의 객체만을 갖도록 한다.
    - 팩터리 메서드 : 어떤 클래스의 객체를 생성하기 위한 인터페이스를 제공하되, 하위 클래스에서 어떤 클래스를 생성할지 결정할 수 있도록 도와준다.

----

## 8. 재귀와 동적 프로그래밍

> 주어진 문제가 재귀 문제인지 확인해 보는 좋은 방법은, 해당 문제를 작은 크기의 문제로 만들 수 있는지 보는 것이다.

### 8.1. 접근법

    재귀적 해법은, 말 그대로 부분문제에 대한 해법을 통해 완성된다.
    가장 흔하게 사용되는 세가지 방법으로는 상향식, 하향식, 그리고 반반이 있다.

    상향식 접근법
        가장 직관적이 ㄴ경우가 많다.
        우선 가장 간단한 경우들에 대한 풀이법을 발견하는 것으로부터 시작한다.
        이 접근법의 핵심은, 이전에 풀었던 사례를 확장하여 다음 풀이를 찾는다는 점이다. 

    하향식 접근법
        덜 명확해서 복잡해 볼 수 있지만, 가끔은 이 방법이 문제에 대해 생각해보기에 가장 좋은 방법이기도 하다.
        이러한 문제들은 어떻게 하면 N에 대한 문제를 부분 문제로 나눌 수 있을지 생각해 봐야 한다.

    반반 접근법
        상향식 접근법과 하향식 접근법 외에 데이터를 절반으로 나누는 방법도 종종 유용하다. 
        예를 들어 이진 탐색은 "반반 접근법"을 이용한 탐색 방법이다. 
        정렬된 배열에서 특정 원소를 찾을 때, 가장 먼저 왼쪽 절반과 오른쪽 절반 중 어디를 봐야 하는지 확인한다.
        병합 정렬 또한 '반반 접근법'을 이용한 정렬 방법이다. 
        배열 절반을 각각 정렬한 뒤 이들을 하나로 병합한다.

### 8.2. 재귀적 해법 vs 순환적 해법

    재귀적 알고리즘을 사용하면 공간 효율성이 나빠질 수 있다. 
    재귀 호출이 한번 발생할 대마다 스택에 새로운 층을 추가해야 한다.
        이는 재귀의 깊이가 n일때 O(n) 만큼의 메모리를 사용하게 된다는 것을 의미한다.
    이런 이유로, 재귀적 알고리즘을 순환적 알고리즘으로 구현하는 것이 더 나을 수 있다.
    재귀적으로 코드를 작성하기 전에, 순환적으로 작성하면 얼마나 더 어려울지 자문해 보고, 두 방법 사이의 타협점에 대해서 면접관과 상의해 보기 바란다.

### 8.3. 동적계획법 & 메모이제이션

    동적 프로그래밍은 ㄷ거의 대부분 재귀적 알고리즘과 반복적으로 호출되는 부분문제를 찾아내는 것이 관건이다.
    이를 찾은 뒤에는 나중을 위해 현재 겨로가를 캐시에 저장해 놓으면 된다.
    혹은 재귀 호출의 패턴을 유심히 살펴본 뒤에 이를 순환적 형태로 구현할 수도 있다. 물론 여전히 결과를 '캐시'에 저장해야 한다.

    하향식 동적 프로그래밍을 메모이제이션이라고 부르기도 상향적 동적 프로그래밍 이 책에서는 둘다 동적 프로그래밍으로 부른다.

----

## 9. 시스템 설계 및 규모 확장성

### 9.1. 문제를 다루는 방법

    소통하라
        - 면접관과 끊임없이 소통하고, 질문하고, 시스템에 발생할 수 있는 문제점을 열린 마음으로 받아들여라.

    처음에는 포괄적으로 접근하라
        - 알고리즘으로 바로 뛰어들지 말고 특정부분을 과도하게 파고들지 말라.

    화이트보드를 사용하라
        - 면접관이 이해할 수 있게

    면접관이 우려하는 부분을 인정하라
        - 면잡관의 우려를 인정하고 적절하게 수정하라

    가정을 할 때 주의하라
        - 잘못된 가정은 문제를 완전히 다르게 바꿔 버릴 수 있다.
        - 일례로 데이터의 통계/분석 결과를 만드는 시스템이 있을때, 이 시스템의 분석 결과가 언제나 최신 결과를 나타내야 하는지 아닌지에 따라 큰 차이가 있다.

    여러분이 생각하는 가정을 명확히 언급하라
      - 가정을 할 때는 그것을 면접관에게 알려줘야 한다. 그래야 여러분이 실수했을 때 면접관이 바로잡아 줄 수 있고, 적어도 여러분이 현재 어떤 가정을 하고 있는지 면접관이 알 수가 있다.

    필요하다면 어림잡아 보라
      - 많은 경우에 여러분이 필요한 데이터가 없을 수 있다. 

    뛰어들라
      - 지원자로서 문제를 책임져야 한다. 조용히 있으면 안되고 반드시 면접관과 이야기를 해야 한다.
      - 그와 동시에 문제도 풀어내야 한다. 질문을 하라. 장단점으 ㄹ열린 마음으로 받아들이라. 계속해서 깊이 파고들라. 계속해서 향상시켜 나가라.

### 9.2. 시스템 설계 : 단계별 접근법

    - 1단계 : 문제의 범위를 한정하라
      - 시스템의 많은 부분을 질문하고 문제의 범위를 한정해야 한다.
       
    - 2단계 : 합리적인 가정을 만들라
      - 필요하다면 가정을 세우는 것도 괜찮지만 합당해야 한다.
      - 어떤 가정을 세우려면 '제품에 대한 감'이 있어야 할 수도 있다. 
       
    - 3단계 : 중요한 부분을 먼저 그리라
      - 시스템의 주요한 부분을 다이어그램으로 그려라
      - 시스템의 처음부터 마지막까지 어떻게 동작하는지 그 흐름을 보이라.
       
    - 4단계 : 핵심 문제점을 찾으라
      - 기본적으로 설계를 마친 뒤에는 발생할 수 있는 핵심 문제에 집중해야 한다.
      - 어느 부분이 병목지점일까?
      - 이 시스템이 풀어야 할 주된 문제는 무엇인가?
       
    - 5단계 : 핵심 문제점을 해결할 수 있도록 다시 설계하라
      - 핵심 문제가 무엇인지 알아냈다면 이제는 그에 맞게 여러분의 설계를 수정해야 한다.
      - 시스템 전체를 갈아 엎어야 할 수도 있고 몇가지 자잘한 부분만 수정해서 해결할 수도 있다.

### 9.3. 규모 확장을 위한 알고리즘 : 단계별 접근법

    - 1단계 : 질문하라
      - 초반에는 문제를 제대로 이해했는지 확인하기 위한 질문 시간이 필요하다.
      - 면접관이 의도적이든 의도적이지 않든 언급하지 않은 세부사항이 잇을 수 있다.
      - 문제가 무엇인지 확실하게 이해하지 못한 상태에서는 문제 자체를 풀 수가 없다.
      
    - 2단계 : 현실적 제약을 무시하라
      - 메모리 제약이 없고, 컴퓨터 한 대에서 모든 데이터를 다 처리할 수 있다고 가정해보자
       
    - 3단계 : 현실로 돌아오라
      - 이제 원래 문제로 돌아와서 컴퓨터 한 대에 저장할 수 잇는 데이터의 크기는 얼마나 되고, 데이터를 여러 조각으로 쪼갰을 때 어떠한 먼제가 발생할지 생각해보라. 
      - 여기서 발생할 수 있는 흔한 문제는 어떤 논리로 데이터를 나눌 것인가, 혹은 특정 컴퓨터가 어느 데이터 조각을 사용했는지 어떻게 알 수 있을 것인가 등이 있다. 
       
    - 4단계 : 문제를 풀어라
      - 마지막으로 2단계에서 발견한 문제점들을 어떻게 해결할지 생각해 봐야 한다. 
      - 상황에 따라 완전 해결 또는 완화시키는데 그칠 수 있다.
      - 일반적으로는 1단계 윤곽을 그린 접근 방식을 살짝 수정해서 사용하겠지만, 가끔은 접근 방식 전체를 바꿔야 할 수도 있다.
      - 순환적 접근법이 일반적으로 유용한 접근법이다. 즉, 3단계에서 어떤 문제를 해결하면 또 다른 문제가 발생하고, 그러면 그 문제를 다시 해결해 나가고 이를 반복하는 작업을 뜻한다.

### 9.4. 시스템 설계의 핵심 개념

#### 9.4.1. 수평적 vs 수직적 규모 확장

    - 수직적 규모 확장
      - 특정 노드의 자원의 양을 늘리는 방법을 말한다.
      - 에를들어, 서버에 메모리르 ㄹ추가해서 서버의 처리 능력을 향상 시킬 수 있다.

    - 수평적 규모 확장
      - 노드의 개수를 늘리는 방법을 말한다. 
      - 예를 들어 서버를 추가함으로써 서버 한 대가 다뤄야 하는 부하를 줄일 수 있다. 

    - 수직적 규모확장이 일반적으로 수평적 규모 확장보다 쉽지만, 메모리 혹은 디스크와 같은 것만 추가할 수 있으므로 제한적이다.

#### 9.4.2. 서버 부하 분산 장치

    - 일반적으로 규모 확장성이 잇는 웹사이트의 프론트엔드 부분은 서버 부하 분산 장치를 통해서 제공된다.
    - 서버의 부하를 균일하게 분산시킬 수 있고 서버 한 대 때문에 전체 시스템이 죽거나 다운되는 상황을 방지할 수 있다. 
    - 물론 이렇게 하기 위해선 서버 여러 대가 근본적으로 똑같은 코드와 데이터를 사용하도록 하는 네트워크를 구현해놔야 한다.

#### 9.4.3. 데이터베이스 역정규화(denormalization)와 NoSQL

    - SQL 같은 관계형 데이터베이스(relational database)의 조인 연산은 시스템이 커질수록 굉장히 느려진다. 따라서 조인 연산은 가능하면 피해야 한다.
      - 역정규화가 이런 것들중 하나다. 

    - 역 정규화란 데이터 베이스에 여분의 정보를 추가해서 읽기 연산 속도를 향상 시킨 것을 의미한다. 
      - 예를 들어, 한 프로젝트가 여러 과제를 수행하도록 설계된 데이터베이스를 생각해 보자.이 데이터베이스에서 프로젝트 이름이랑 과제 정보를 함꼐 알고 싶은 경우에 두 테이블을 조인하기보단 애초에 과제 테이블에 프로젝트 이름 정보를 추가로 저장해 놓으면 더 빠르게 작업을 수행할 수 있따.

    - 혹은 NoSQL 데이터베이스를 사용할 수도 있다. 
      - NoSQL 은 조인 연산 자체를 지원하지 않는다. 
      - 따라서 조금 다른 방식으로 구성해 놓는데, 이 방식이 규모 확장성에 좋도록 설계되어 있다. 

### 9.5. 데이터베이스 분할(샤딩)

    샤딩은 데이터를 여러 컴퓨터에 나눠서 저장하는 동시에 어떤 데이터가 어떤 컴퓨터에 저장되어 있는지 알 수 있는 방식을 말한다.
    흔하게 사용되는 분할 방식에는 다음이 있다.

    - 수직적 분할 :
      - 기본적으로 자료의 특성별로 분할하는 방식
      - 예를들어 SNS는 개인정보, 메시지 등의 그 특성에 따라 자료를 분할
      - 단점은 특정 테이블의 크기가 일정 수준 이상으로 커지면, (다른 방식을 사용해서) 데이터베이스를 재분할해야 할 수도 있다.

    - 키 혹은 해시 기반 분할 : 
      - 이 방법을 아주 간단하게 구현하면 N개의 서버에 분할 저장하면 된다. 
      - 한 가지 문제점은 서버의 개수가 사실상 고정되어 있어야 한다는 점이다. 
      - 서버를 새로 추가할 때마다 모든 데이터를 다시 재분배해야 하는데, 굉장히 비용이 큰 작업이다.

    - 디렉토리 기반 분할
      - 데이터를 찾을 때 사용되는 조회 테이블을 유지하는 방법이다.
      - 이 방법이 상대적으로 서버를 추가하기 쉽지만, 두가지 심각한 단점이 있다.
        - 첫 번째 : 조회 테이블이 단일 장애 지점이 될 수도 있고
        - 두 번째 : 지속적으로 테이블을 읽는 행위가 전체 성능에 영향을 미칠 수 있다. 

#### 9.5.1. 캐싱

    - 인메모리 캐싱을 사용하면 결과를 굉장히 빠르게 가져올 수 있다.
    - 인 메모리 캐시는 키-값을 쌍으로 갖는 간단한 구조로써 일반적으로 애플리케이션과 데이터 저장소 사이에 자리잡고 있다.
    - 애플리케이션이 어떤 자료를 요청하며 ㄴ캐시를 확인하고 없다면 데이터 저장소를 찾아본다.
    - 캐시를 할 때는 쿼리와 그 결과를 캐시하는 경우가 많다. 혹은 특정 객체를 캐시에 저장할 수도 있다. 예를들어 어떤 부분을 랜더링한 결과나 혹은 블로그에 올라온 취근 포스팅 리스트가 있을 수 있다.

#### 9.5.2. 비동식 처리 & 큐

    - 이상적이라면, 속도가 느린 연산은 비동기식으로 처리해야 한다. 
    - 어떤 경우에는 이 연산을 미리 해 놓을 수도 있다.

#### 9.5.3. 네트워크 성능 척도

    네트워크의 성능을 측정할 때 사용되는 몇가지 중요한 척도는 다음과 같다.

    - 대역폭 bandwidth : 
        - 단위 시간에 전송할 수 있는 데이터의 최대치를 말한다. 보통 초당 몇비트, 또는 초당 몇 기가 바이트로 계산한다.

    - 처리량 throughput : 
        - 단위 시간에 전송할 수 있는 데이터의 최대치를 말하는 반면, 처리량은 단위 시간에 실제로 전송된 데이터의 양을 의미한다.

    - 지연 속도 latency : 
        - 데이터를 전송하는 데 걸리는 시간을 말한다. 즉, 발송자가 데이터를 보낸 시점부터 수신자가 데이터를 받는 시점까지 걸린 시간을 말한다.
        - 지연 시간은 무시되기 쉽지만 특정 상황에선 굉장히 중요한 역할을 한다.

#### 9.5.4. MapReduce

    MapReduce 프로그램은 보통 굉장히 커다란 데이터를 처리하는데 사용한다.
    사용하려면 Map 단계와 Reduce 단계르 ㄹ구현해야 한다.
    나머지 부분은 시스템이 알아서 처리할 것이다.

    - Map 은 데이터를 입력으로 받은 뒤 key value 쌍을 반환한다.
    - Reduce 는 key, 그리고 키와 관련된 값들을 입력으로 받은 뒤 나름의 처리 과정을 거친 뒤 새로운 키와 값을 반환한다.
    - 경우에 따라 이 결과를 또 다른 Reduce 프로그램에 넘길 수도 있다.
    - MapReduce는 많은 과정을 병렬로 처리할 수 있게 도와주기 때문에 굉장히 커다란 데이터에 대해서도 규모 확장이 쉬워진다. 

### 9.5. 시스템 설계 시 고려할 점

    실패 : 
        시스템의 어떤 부분이든 실패 가능성이 존재한다.
        따라서 각 부분이 실패했을 때를 대비한 대비책을 준비해야 한다

    가용성 및 신뢰성 (availability and reliability) : 
        가용성은 사용 가능한 시스템의 시간을 백분율로 나타낸 것을 말한다. 
        신뢰성은 특정 단위 시간에 시스템이 사용 가능할 확률을 나타낸 것을 말한다.

    읽기 중심 vs 쓰기 중심 :
        읽는 연산이 많은지 아니면 쓰는 연산이 많은지에 다라 설계 방식이 달라질 수 있다.
        쓰는 연산이 많다면, 큐를 사용하는 방법은 한번 생각해 보라.
        읽는 연산이 많다면, 캐시를 사용하는 것이 좋을 수도 있다.

    보안 : 
        보안 위협은 시스템에 엄청난 해를 가할 수 있다. 
        해당 시스템이 직면할 수 있는 문제점에 대해 생각해 보고 그를 해결하기 위해 어떻게 시스템을 설계할지 생각해보라

### 9.6. '완벽한' 시스템은 없다.

    모든 시스템에는 장단점이 존재한다.
    두 사람이 같은 시스템을 완전히 다르게 설계했더라도 어느 하나가 모든 면에서 다른 하나보다 나은 경우는 없다.
    서로 다른 상황에서 두 시스템 모두 굉장한 성능을 낼 수 있다. 
    이런 종류의 문제를 받았을 때 여러분이 해야 할 일은 사례를 잘 이해하고, 문제의 범위를 설정하고, 합리적으로 가정을 세운 뒤, 명확하게 설계한 시스템을 만드는 것이다.

### 9.7. 연습 문제

    책 참조하기

------

## 10. 정렬과 탐색

### 10.1. 널리 사용되는 정렬 알고리즘

    자주 사용되는 정렬 알고리즘을 알아 두면 여러분의 문제풀이 능력을 크게 향상시킬 수 있다.

    자주 출제되는 알고리즘은
        병합 정렬
        퀵 정렬
        버킷 정렬이다.

    버블 정렬
        배열의 첫 원소부터 순차적으로 진행하며, 현재 원소가 그 다음 원소의 값보다 크면 두 원소를 바꾸는 작업을 반복한다.

    선택 정렬
        아이들도 고안해 낼 수 잇을 만큼 심플한 알고리즘이고 비효울적이다.
        선형 탐색하며 가장 작은 원소를 배열 맨 앞으로 보낸다.
        그 다음 두 번째로 작은 원소를 찾아 앞으로 보낸다.
        반복....

    병합 정렬
        배열을 절반씩 나누어 각각을 정렬한 다음 이 둘을 합하여 다시 정렬하는 방법이다.

    퀵 정렬
        무작위로 선정된 한 원소를 사용하여 배열을 분할하는데, 선정된 원소보다 작은 원소들은 앞에, 큰 원소들은 뒤로 보낸다.

    기수 정렬
        데이터가 정수처럼 유한한 비트로 구성되어 있는 경우에 사용된다.
        기수 정렬은 각 자릿수를 순회해 나가면서 각 자리의 값에 따라 그룹을 나눈다. 
        
    탐색 알고리즘
        탐색 알고리즘 하면 일반적으로 이진 탐색이 떠오른다. 실제로 이진 탐색은 공부하기 굉장히 좋은 알고리즘이다.
        이진 탐색은 정렬된 배열에서 원소 X를 찾고자 할 때 사용된다.
            x를 중간에 위치한 원소와 비교한 뒤, x가 중간에 위치한 값보다 작다면 배열의 왼쪽 절반을 재탐색하고, 크다면 배열의 오른쪽 절반을 재탐색한다.
        자료구조를 탐색하는 방법은 이진 탐색 말고도 많으니 너무 집착하지 말기를 바란다.

---

## 11. 테스팅

    테스팅과 관련된 질문들은 보통 네 가지 범주 중 하나에 속한다.
    1. 실생활에서 접하는 객체(예를 들어 펜과 같은)를 테스트하라.
    2. 소프트웨어 하나를 테스트하라
    3. 주어진 함수에 대한 테스트코드를 작성하라
    4. 발생한 이슈에 대한 해결책을 찾아내라.

### 11.1. 면접관이 평가하는 것

    - 큰 그림을 이해하고 있는가
        - 소포트웨어가 지향하는 바가 무엇인지 정말로 이해하고 있는 사람인가?
        - 테스트 케이스간의 우선순위를 적절히 매길수 있는가?

    - 퍼즐 조각을 제대로 맞추는 방법을 아는가
        - 소프트웨어가 어떻게 동작하는지, 그리고 각 소프트웨어가 보다 더 큰 생태계의 일부로 어떻게 귀속되는지를 이해하는 것인가?

    - 조직화
        - 문제에 구조적으로 접근하고 있는가, 아니면 생각나는 대로 아무 방법이나 질러보고 있는가?
        - 예를들어 카메라에 대한 테스트라면 촬영, 이미지 관리, 설정 등의 범주로 시스템을 나눈 다음에 테스트를 만들어간다.

    - 실용성
        - 실제로 적용 가능한 합리적인 테스트 계획을 세울 수 있나?


### 11.2. 실제 세계에서 객체 테스트하기

    예시로 설명 클립을 테스트하려면 어떻게하겠나?

    1단계 : 사용자는 누구인가? 클립의 사용 목적은 무엇인가?
        - 문제를 풀기 전에 해당 제품을 어떤 사용자가 어떤 목적으로 사용하게 될지 면접관과 의논해 봐야 한다.

    2단계 : 어떤 유스 케이스가 있다?
        - 이 문제의 경우에는 "종이 다발을 망가뜨리지 않고 함께 묶어 놓는다"가 될 것이다. 

    3단계 : 한계 조건은?
        - 한 번에 30장을 영구적 손상 없이 묶을 수 잇다거나 그런것들.
        - 환경적 요인이 있을 수도 있다.

    4단계 : 스트레스 조건과 장애 조건은?
        - 문제가 없는 제품은 없다.
        - 장애가 발생하는 조건을 분석하는 것도 여러분이 해야 하는 일이다.

    5단계 : 테스트는 어떻게 수행할 것인가?
        - 테스트를 어떻게 수행할지 토론하는 것은 테스트와 관련된 세부사항을 이야기하는 것과 관련이 있다.
        - 수작업 테스트 이외에도, 기계가 수행하는 자동화된 테스트를 도입하는 것도 고려해 봐야 한다.

### 11.3. 소프트웨어 테스팅

    하나의 소프트웨어를 테스트 하는 것은 실제 세계의 테스트를 하는 것과 아주 유사하다.
    가장 큰 차이점은 *** 소프트웨어의 경우 성능 테스트의 세부사항을 더 많이 강조한다는 것이다.***



#### 11.3.1. 소프트웨어 테스팅의 두가지 핵심 측면

    - 수작업 테스트 vs 자동화된 테스트
      - 이상적으로는 모든 것을 자동화하면 좋겠지만, 불가능한 일이다.

    - 블랙박스 테스트 vs 화이트박스 테스트
      - 이런 구분은 소프트웨어 내부를 어디까지 들여다 볼 수 있느냐에 근거한 것이다.
      - 블랙박스 테스트의 경우는 소프트웨어를 주어진 그대로 테스트해야 한다.
      - 화이트박스 테스트의 경우 그 내부의 개별 함수들을 프로그램적으로 접근하여 테스트할 수 잇다.
      - 블랙박스도 자동화가 되긴 하지만 훨씬 더 어렵다.
     

### 11.4. 함수 테스트

    함수 테스트는 가장 쉬운 종류의 테스트다.

    보통 입력과 출력을 확인하는 테스트만 하면 되기 때문에, 면접관과 길게 얘기할 것도 없고 모호한 부분도 적다.
    그래도 대화의 중요성을 관과해서는 안된다.
    어떤 가정을 하건, 면접관과 그에 대해 대화를 해야 한다.


#### 11.4.1. 함수를 테스트할 때 다음과 같이 진행하는 것이 좋다.

    1단계 : 테스트 정의
        정상적인 케이스
        극단적인 케이스
        null 입력, 잘못된 입력
        특수한 입력

    2단계 : 예상되는 결과를 정의하라
        예상되는 결과는 대체로 명확하게 정의할 수 있다.
        대체로 올바른 결과를 말한다.
        하지만 오류가 발생할 부분도 예상해서 테스트 해야 한다.

    3단계 : 테스트 코드를 작성하라.

### 11.5. 문제 해결에 관한 문제

    1단계 : 시나리오를 이해하라
        이해할 수 있도록 많은 질문을 던지는 것이다.

    2단계 : 문제를 쪼개라
        문제를 테스트 가능한 단위로 분할한다.
        흐름과 상황의 전개 순으로 분할한다.

    3단계 : 구체적이고 관리 가능한 테스트들을 생성하라
        방금 살펴본 구성요소들 각각에 대한 현실적인 지시사항이 있어야 한다.
        사용자가 직접 해볼 수도 있고, 여러분이 직접 해볼 수도 있는 것들 말이다.


----

## 12. C와 C++

>> C와 C++은 저의 범위와 다르므로 넘어가겠습니다.
>

------

## 13. 자바

### 13.1. 언어 자체 질문에 대한 접근법

    자바 언어에 대하여 다음과 같은 접근법을 이용해보자

        1. 예제 시나리오를 만들어 보고 어떻게 전개되어야 하는지 자문해 보라.
        2. 다른 언어에선 이 시나리오를 어떻게 처리할 것인지 자문해 보라.
        3. 프로그래밍 언어를 설계하는 사람이라면 이 상황을 어떻게 설계할 것인지 생각해 보라. 어떤 선택이 결과로 이어지는가?

    오버로딩 vs 오버라이딩

        오버로딩
            두 메서드가 같은 이름을 갖고 있으나 인자의 수나 자료형이 다른 경우를 지칭한다.

        오버라이딩
            반면에 오버라이딩은 상위 클래스의 메서드 이름과 용례가 같은 함수를 하위 클래스에 재정의하는 것을 의미한다.

    컬렉션 프레임워크

        ArrayList
            동적으로 크기가 조절되는 배열이다. 새 원소를 삽입하고 가득차면 10을 시작으로 2배씩 늘어난다.

        Vector
            ArrayList와 비슷하지만 동기화되어 있다는 차이가 있다. 문법은 거의 동일하다.

        LinkedList
            자바에서 제공하는 LinkedList를 말한다. 이 클래스에 관해 묻는 경우는 별로 없지만, 순환자를 어떻게 사용해야 하는지를 잘 보여 주므로 알아 두면 좋다.

        HashMap
            면접이나 실제 상황 가릴 것 없이 광범위하게 사용된다.


----

## 14. 데이터베이스


### 14.1. SQL 문법과 그 변종들

    명시적 조인과 묵시적 조인은 개인 취향의 문제다.

    명시적 JOIN
        " selec coursename, teachername from courses INNER JOIN ..."
    
    묵시적 JOIN 
        "SELECT courname, teachername from courses, teachers WHERE Course.teacher.ID = teachers.teacherID"


### 14.2. 비정규화 vs 정규화 데이터베이스

    정규화 데이터 베이스는 
        중복을 최소화하도록 설계된 데이터 베이스를 말한다.
        정보를 데이터베이스에 한 번만 저장해도 된다는 장점이 있다.
        JOIN 을 많이 하게 된다는 단점이 있다.

    비정규화 데이터 베이스는 읽는 시간을 최적화하도록 설계된 데이터베이스를 말한다.
        데이터를 중복해서 저장할 수 있다.
        비정규화는 높은 규모 확장성을 실현하기 위해 자주 사용되는 기법이다.


### 14.3. SQL 문

    // SKIP


### 14.4.소규모 데이터베이스 설계

    면접장에서 데이터베이스를 설계해 보라는 요청을 받을 수도 잇다. 
    여기서는 그런 질문을 받았을 때를 대비한 접근법에 대해 살펴볼 것이다.
    읽다 보면 이 접근법이 객체 지향 설계와 비슷한 점이 많다는 것을 눈치챌 것이다.

    1단계 : 모호성 처리
        설계를 시작하기 전에 정확히 무엇을 설계해야 하는지 이해해야 한다;.
    
    2단계 : 핵심 객체 정의
        시스템의 핵심 객체가 무엇인지 살펴봐야 한다;
        보통 핵심 객체 하나당 하나의 테이블을 사용한다

    3단계 : 관계 분석
        핵심 객체의 윤곽을 잡고 나면 어떻게 테이블을 설계해야 할지 감을 잡을 수 있을 것이다.
        테이블끼리 어떤 관계가 있을까? 다 대 다 관계인가? 아니면 일 대 다 관계인가?

    4단계 : 행위 조사
        마지막으로 세부적인 부분을 채워 넣어야 한다.
        흔하게 수행될 작업들을 살펴보고 관련된 데이터를 어떻게 저장하고 가져올 것인지 이해해야 한다.
        종종 새로운 테이블이 필요한 경우도 있다. 


### 14.5. 대규모 데이터 베이스 설계

    대규모의 확장성이 높은 데이터베이스를 설계할 때에 JOIN 연산은 일반적으로 아주 느리다고 간주해야 한다. 따라서 데이터를 비정규화해야 한다.

    데이터를 여러 테이블에 중복해서 저장해야 할지도 모르니 데이터가 어떻게 사용될지 유심히 살펴보길 바란다.


-----

## 15. 스레드와 락

### 15.1. 자바의 스레드

    자바의 모든스레드는 java.lang.Thtread 클래스 객체에 의해 생성되고 제어된다.
    독립적인 응용 프로그램이 실행될 떄, main() 메서드를 실행하기 위한 하나의 사용자 스레드가 자동으로 만들어지는데, 이 스레드를 주 스레드라고 부른다.
    자바에서 스레드를 구현하는 방법으로는 다음 두 가지가 있다. 

    - java.lang.Runnable 인터페이스를 구현하기
    - java.lang.Thread 클래스를 상속받기

#### 15.1.1. Runnable 인터페이스를 구현하는 방법

    Runnable의 구조는 단순하다.
    ```java
    public interface Runnable {
        void run();
    }
    ```
    - Runnable 인터페이스의 구현 클래스를 만든다.
    - Thread타입의 객체를 만들떄, 스레드의 생성자에 Runnable 객체를 인자로 넘긴다.
    - 스레드의 start메서드를 호출한다.

#### 15.1.2. Thread 클래스 상속

    위 방식 외에 스레드 클래스를 상속받아 스레드를 만들 수도 있다. 
    그러려면 거의 항상 ```run()```메서드를 오버라이드 해야하며
        , 하위 클래스의 생성자는 상위 클래스의 생성자를 명시적으로 호출해야 한다.
    인터페이스를 구현하는 대신 스레드 클래스를 상속받아, 인스턴스 자체에서 start()를 직접 호출하게 된다.


### 15.2. 동기화와 락

    어떤 프로세스 안에서 생성된 스레드들은 같은 메모리 공간을 공유한다. 그래서 좋을 때도 있고 나쁠 때도 있다. 
    두 스레드가 같은 자원을 동시에 변경하는 경우에는 문제가 된다.
    자바는 공유 자원에 대한 접근을 제어하기 위한 동기화 방법을 제공한다.

    synchronized와 Lock 이라는 키워드는 동기화 구현을 위한 기본이 된다. 

#### 15.2.1. 동기화된 메서드

    통상적으로 syncrhonized 키워드를 사용할 때는 공유 자원에 대한 접근을 제어한다.
    이 키워드는 메서드에 적용할 수도 있고, 특정한 코드 블록에 적용할 수도 있다. 
    이 키워드는 여러 스레드가 같은 객체를 동시에 실행하는 것 또한 방지해준다. 

    synchronized 메서드를 가지고 있는 인스턴스 혹은 객체가 서로 다른 객체인 경우 동시 호출이 가능하지만 다른 인스턴스일 경우는 기다려야 한다.


    정적 메서드는 클래스 락에 의해 동기화된다. 
        "public static synchronized void foo(String name){}"  
        같은 클래스에 있는 동기화된 정적 메서드는 두 스레드에서 동시에 실행될 수 없다. 
        설사 하나는 foo를 호출하고 다른 하나는 bar를 호출한다고 해도 말이다.

#### 15.2.2. 동기화된 블록

    이와 비슷하게, 특정한 코드 블록을 동기화할 수도 있다. 
    이는 메서드를 동기화하는 것과 아주 비슷하게 동작한다.

    메서드를 동기화하는 것과 마찬가지로
    , MyObject 인스턴스 하나당 하나의 스레드만이 synchronized 블록 안의 코드를 실행할 수 있다.


#### 15.2.3. 락

    좀 더 세밀하게 동기화를 제어하고 싶을 때는 락을 이용한다.
    락을 공유 자원에 붙이면 해당 자원에 대한 접근을 동기화할 수 있다. 
    스레드가 해당 자원을 접근하려면 우선 그 자원에 붙어 있는 락을 획득해야 한다.
    
    특정 시점에 락을 쥐고 있는 스레드는 하나 뿐이다. 따라서 해당 공유자원은 한 번에 한 스레드만이 사용할 수 있다. 
    어떤 자원이 프로그램 내의 이곳저곳에서 사용되지만 한 번에 한 스레드만 사용하도록 만들고자 할 때 주로 락을 이용한다.
    
    락을 사용하면 공유된 자원이 예기치 않게 변경되는 일을 막을 수 잇다. 

### 15.3. 교착상태와 교착상태 방지

    교착상태란,

        첫 번째 스레드는 두번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있고,
        두 번째 스레드는 첫번째 스레드가 들고 있는 객체의 락이 풀리기를 기다리고 있어
        모든 스레드가 락이 풀리기를 기다리고 있는 무한 대기 상태에 빠지는 상황을 의미한다.


    교착상태가 발생하기 위한 네 가지 조건.

        1. 상호 배제 : 한 번에 한 프로세스만 공유 자원을 사용할 수 있다. 
        2. 들고 기다리기 : 공유 자원에 대한 접근 권한을 갖고 있는 프로세스가, 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다. 
        3. 선취 불가능 : 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다.
        4. 대기 상태의 사이클 : 두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.
        교착상태를 방지하기 위해선 이 조건들 가운데 하나를 제거하면 된다.

---

## 16. 중간 난이도 연습 문제

> 이후 해법과 함께 다루기

----

## 17. 어려운 연습문제

> 이후 해법과 함께 다루기
